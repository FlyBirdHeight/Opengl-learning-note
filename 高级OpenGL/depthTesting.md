## 深度测试

​		**深度缓冲就像颜色缓冲(Color Buffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。**深度缓冲是由**窗口系统自动创建**的，它会**以16、24或32位float的形式储存它的深度值**。在大部分的系统中，深度缓冲的精度都是24位的。

​		当深度测试(Depth Testing)被启用的时候，*OpenGL*会将**一个片段的的深度值与深度缓冲的内容进行对比**。*OpenGL*会执行一个深度测试，**如果这个测试通过了的话，深度缓冲将会更新为新的深度值。如果深度测试失败了，片段将会被丢弃。**

​		**深度缓冲是在片段着色器运行之后（以及模板测试(Stencil Testing)运行之后）在屏幕空间中运行的。**屏幕空间坐标与通过`OpenGL`的`glViewport`所定义的视口密切相关，并且可以直接使用`GLSL`内建变量`gl_FragCoord`从片段着色器中直接访问。`gl_FragCoord`的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。`gl_FragCoord`中也包含了一个z分量，它包含了片段真正的深度值。z值就是需要与深度缓冲内容所对比的那个值。

<div style="border:2px solid #AFDFAF;background-color:#D8F5D8;border-radius:5px;margin:10px;padding:15px">
    <p>
    现在大部分的GPU都提供一个叫做提前深度测试(Early Depth Testing)的硬件特性。提前深度测试允许深度测试在片段着色器之前运行。只要我们清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。
    </p><p>
    片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL不能提前知道深度值。
    </p></div>

```c++
//开启深度测试，默认是被禁用的
glEnable(GL_DEPTH_TEST);

//当深度测试被启用之后，Opengl会在深度缓冲中存储该片段的z值(通过深度测试的情况下);如果未通过深度测试，就会被丢弃。而且需要记得，在每次迭代渲染的之前，需要将上一次的深度缓冲清除，否则就会继续使用上一次缓冲的深度值
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
//这段在while中
```

​		可以想象，在某些情况下你会需要对所有片段都执行深度测试并丢弃相应的片段，但**不**希望更新深度缓冲。基本上来说，你在使用一个只读的(Read-only)深度缓冲。*OpenGL*允许我们禁用深度缓冲的写入，只需要设置它的深度掩码(Depth Mask)设置为`GL_FALSE`就可以了：

```c++
//注意这只在深度测试被启用的时候才有效果。
glDepthMask(GL_FALSE);
```

### 深度测试函数

*OpenGL*允许我们修改深度测试中使用的比较运算符。这允许我们来控制*OpenGL*什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。**我们可以调用`glDepthFunc`函数来设置比较运算符（或者说深度函数(Depth Function)）**：

| 函数        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| GL_ALWAYS   | 永远通过深度测试                                             |
| GL_NEVER    | 永远不通过深度测试                                           |
| GL_LESS     | 在片段深度值小于缓冲的深度值时通过测试<font style="color:red;font-weight:bolder">（默认值）</font> |
| GL_EQUAL    | 在片段深度值等于缓冲区的深度值时通过测试                     |
| GL_LEQUAL   | 在片段深度值小于等于缓冲区的深度值时通过测试                 |
| GL_GREATER  | 在片段深度值大于缓冲区的深度值时通过测试                     |
| GL_NOTEQUAL | 在片段深度值不等于缓冲区的深度值时通过测试                   |
| GL_GEQUAL   | 在片段深度值大于等于缓冲区的深度值时通过测试                 |

### 深度值精度

​		深度缓冲包含了一个介于0.0和1.0之间的深度值，它将会与观察者视角所看见的场景中所有物体的z值进行比较。观察空间的z值可能是投影平截头体的**近平面**(Near)和**远平面**(Far)之间的任何值。我们需要一种方式来将这些观察空间的z值变换到[0, 1]范围之间，其中的一种方式就是将它们线性变换到[0, 1]范围之间。下面这个（线性）方程将z值变换到了0.0到1.0之间的深度值：
$$
\begin{equation} F_{depth} = \frac{z - near}{far - near} \end{equation}
$$
​		这里的*near*和*far*值是我们之前提供给投影矩阵设置可视平截头体的那个 *near* 和 *far* 值。这个方程需要平截头体中的一个z值，并将它变换到了[0, 1]的范围中。z值和对应的深度值之间的关系可以在下图中看到(far = 100.0, near = 1.0)：

![avatar](C:\Users\adsionli\Desktop\note\Opengl-learning-note\image\depth_linear_graph.png)

<div style="border:2px solid #AFDFAF;background-color:#D8F5D8;padding:15px;margin:10px;border-radius:5px">注意所有的方程都会将非常近的物体的深度值设置为接近0.0的值，而当物体非常接近远平面的时候，它的深度值会非常接近1.0。</div>

​		然而，**在实践中是几乎永远不会使用这样的线性深度缓冲(Linear Depth Buffer)的**。**要想有正确的投影性质，需要使用一个非线性的深度方程**，它是与 1/z 成正比的。**它做的就是在z值很小的时候提供非常高的精度，而在z值很远的时候提供更少的精度。**花时间想想这个：我们真的需要对1000单位远的深度值和只有1单位远的充满细节的物体使用相同的精度吗？线性方程并不会考虑这一点。

​		由于非线性方程与 1/z 成正比，在1.0和2.0之间的z值将会变换至1.0到0.5之间的深度值，这就是一个float提供给我们的一半精度了，**这在z值很小的情况下提供了非常大的精度。在50.0和100.0之间的z值将会只占2%的float精度**，这正是我们所需要的。这样的一个考虑了远近距离的方程是这样的：
$$
\begin{equation} F_{depth} = \frac{1/z - 1/near}{1/far - 1/near} \end{equation}
$$
​		如果你不知道这个方程是怎么回事也不用担心。**重要的是要记住深度缓冲中的值在屏幕空间中不是线性的（在透视矩阵应用之前在观察空间中是线性的）**。深度缓冲中0.5的值并不代表着物体的z值是位于平截头体的中间了，这个顶点的z值实际上非常接近近平面！你可以在下图中看到z值和最终的深度缓冲值之间的非线性关系：

![avatar](C:\Users\adsionli\Desktop\note\Opengl-learning-note\image\depth_non_linear_graph.png)

​		深度值很大一部分是由很小的z值所决定的，这给了近处的物体很大的深度精度。这个（从观察者的视角）变换z值的方程是嵌入在投影矩阵中的，所以当我们想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了。

### 深度缓冲的可视化

