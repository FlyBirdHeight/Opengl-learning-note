## 模板测试

​		**当片段着色器处理完一个片段之后，模板测试(Stencil Test)会开始执行**，和深度测试一样，它也可能会丢弃片段。接下来，被保留的片段会进入深度测试，它可能会丢弃更多的片段。**模板测试是根据又一个缓冲来进行的，它叫做模板缓冲(Stencil Buffer)**，我们可以在渲染的时候更新它来获得一些很有意思的效果。

​		**一个模板缓冲中，（通常）每个模板值(Stencil Value)是8位的**。所以每个像素/片段一共能有256种不同的模板值。**我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了**。

<div style="border:2px solid #AFDFAF;background-color:#D8F5D8;margin:10px;padding:15px;border-radius:5px">每个窗口库都需要为你配置一个模板缓冲。GLFW自动做了这件事，所以我们不需要告诉GLFW来创建一个，但其它的窗口库可能不会默认给你创建一个模板库，所以记得要查看库的文档。</div>

模板缓冲的一个简单的例子如下：

![avatar](..\image\stencil_buffer.png)

​		**模板缓冲首先会被清除为0**，之后**在模板缓冲中使用1填充了一个空心矩形**。场景中的片段将会只在片段的模板值为1的时候会被渲染（其它的都被丢弃了）。

​		模板缓冲操作允许我们在渲染片段时将模板缓冲设定为一个特定的值。通过在渲染时修改模板缓冲的内容，我们**写入**了模板缓冲。在同一个（或者接下来的）渲染迭代中，我们可以**读取**这些值，来决定丢弃还是保留某个片段。使用模板缓冲的时候你可以尽情发挥，但大体的步骤如下：

- 启用模板缓冲的写入。

- 渲染物体，更新模板缓冲的内容。

- 禁用模板缓冲的写入。

- 渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。

  ​	所以，通过使用模板缓冲，我们可以根据场景中已绘制的其它物体的片段，来决定是否丢弃特定的片段。

  ​	你可以启用`GL_STENCIL_TEST`来启用模板测试。在这一行代码之后，所有的渲染调用都会以某种方式影响着模板缓冲。

```c++
//启用模板测试
glEnable(GL_STENCIL_TEST);
//每一次渲染迭代之前清楚模板缓冲，避免上一次缓冲对新一次迭代造成影响
glClear(GL_COLOR_BUFFER_BTI | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
//glStencilMask允许我们设置一个位掩码(Bitmask)，它会与将要写入缓冲的模板值进行与(AND)运算。默认情况下设置的位掩码所有位都为1，不影响输出，但如果我们将它设置为0x00，写入缓冲的所有模板值最后都会变成0.这与深度测试中的glDepthMask(GL_FALSE)是等价的。
glStencilMask(0xFF); // 每一位写入模板缓冲时都保持原样
glStencilMask(0x00); // 每一位在写入模板缓冲时都会变成0（禁用写入）
//大部分情况下都只会使用0x00或者0xFF作为模板掩码(Stencil Mask)，但是知道有选项可以设置自定义的位掩码总是好的。
```

### 模板函数

和深度测试一样，我们对模板缓冲应该通过还是失败，以及它应该如何影响模板缓冲，也是有一定控制的。一共有两个函数能够用来配置模板测试：`glStencilFunc`和`glStencilOp`。

`glStencilFunc(GLenum func, GLint ref, GLuint mask)`一共包含三个参数：

- `func`: 设置模板测试函数。这个测试函数将会被用到已经储存的模板值上和`glStencilFunc`函数的`ref`值上。可用的选项有：`GL_NEVER`、`GL_LESS`、`GL_LEQUAL`、`GL_GREATER`、`GL_GEQUAL`、`GL_EQUAL`、`GL_NOTEQUAL`和`GL_ALWAYS`。它们的语义和深度缓冲的函数类似。
- `ref`: 设置了模板测试的参考值。模板缓冲的内容将会与这个值进行比较
- `mask`：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1。

```c++
//这会告诉OpenGL，只要一个片段的模板值等于(GL_EQUAL)参考值1，片段将会通过测试并被绘制，否则会被丢弃。
glStencilFunc(GL_EQUAL, 1, 0XFF);
```

`glStencilFunc`只能够描述OpenGL应该对模板缓冲内容做什么，但是不知道应该如何更新缓冲。所以需要用到`glstencilOp`这个函数，来对缓冲进行更新

`glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)`一共包含三个选项，我们能够设定每个选项应该采取的行为：

- `sfail`:模板测试失败时采取的行为
- `dpfail`:模板测试通过，但是深度测试失败时采取的行为
- `dppass`:模板与深度测试均通过时采取的行为

每个选项都可以选用以下的其中一种行为：

| 行为         | 作用                                               |
| ------------ | -------------------------------------------------- |
| GL_KEEP      | 保持当前储存的模板值                               |
| GL_ZERO      | 将模板值设置为0                                    |
| GL_REPLACE   | 将模板值设置为glStencilFunc函数设置的`ref`值       |
| GL_INCR      | 如果模板值小于最大值则将模板值加1                  |
| GL_INCR_WRAP | 与GL_INCR一样，但如果模板值超过了最大值则归零      |
| GL_DECR      | 如果模板值大于最小值则将模板值减1                  |
| GL_DECR_WRAP | 与GL_DECR一样，但如果模板值小于0则将其设置为最大值 |
| GL_INVERT    | 按位翻转当前的模板缓冲值                           |

​		默认情况下`glStencilOp`是设置为`(GL_KEEP, GL_KEEP, GL_KEEP)`的，所以不论任何测试的结果是如何，模板缓冲都会保留它的值。默认的行为不会更新模板缓冲，所以如果你想写入模板缓冲的话，你需要至少对其中一个选项设置不同的值。

​		所以，通过使用`glStencilFunc`和`glStencilOp`，我们可以精确地指定更新模板缓冲的时机与行为了，我们也可以指定什么时候该让模板缓冲通过，即什么时候片段需要被丢弃。

### 物体轮廓

​		**物体轮廓所能做的事情正如它名字所描述的那样。我们将会为每个（或者一个）物体在它的周围创建一个很小的有色边框**。当你想要在策略游戏中选中一个单位进行操作的，想要告诉玩家选中的是哪个单位的时候，这个效果就非常有用了。为物体创建轮廓的步骤如下：

1. 在绘制（需要添加轮廓的）物体之前，将模板函数设置为`GL_ALWAYS`，每当物体的片段被渲染时，将模板缓冲更新为1。

2. 渲染物体。

3. 禁用模板写入以及深度测试。

4. 将每个物体缩放一点点。

5. 使用一个不同的片段着色器，输出一个单独的（边框）颜色。

6. 再次绘制物体，但只在它们片段的模板值不等于1时才绘制。

7. 再次启用模板写入和深度测试。

   ​		**这个过程将每个物体的片段的模板缓冲设置为1**，当我们想要绘制边框的时候，我们**主要绘制放大版本的物体中模板测试通过的部分**，也就是物体的边框的位置。我们主要**使用模板缓冲丢弃了放大版本中属于原物体片段的部分。**

   首先绘制地板，再绘制两个箱子（并写入模板缓冲），之后绘制放大的箱子（并丢弃覆盖了之前绘制的箱子片段的那些片段）。

   具体代码实现过程

   ```glsl
   //设置箱体边框颜色
   void main(){
   	FragColor = vec4(0.04, 0.28, 0.26, 1.0);
   }
   ```

   ```c++
   //开启模型测试
   glEnable(GL_STENCIL_TEST);
   //设置模板函数，指定在更新的时候，同时通过模型测试和深度测试后替换为glStencilFunc函数中的ref参数,不同时通过时就保留原值
   glStencilOp(GL_KEAP, GL_KEAP, GL_REPLACE);
   //模板缓冲清除为0，对箱子中所有绘制的片段，将模板值更新为1：
   glStencilFunc(GL_ALWAYS, 1, 0xFF); // 所有的片段都应该更新模板缓冲
   glStencilMask(0xFF); // 启用模板缓冲写入，不允许写入使用glStencilMask(0x00)
   normalShader.use();
   DrawTwoContainers();
   //当我们将箱子在被绘制的地方全部更新为1，为了再次绘制放大后的箱子，需要将模板缓冲禁止写入
   glStencilFunc(GL_NOTEQUAL, 1, 0xFF);
   glStencilMask(0x00);
   glDisable(GL_DEPTH_TEST);
   ShaderSingleColor.use();
   DrawTwoScaledUpContainers();
   
   ```

   

