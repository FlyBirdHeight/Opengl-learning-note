## 投光物

>  将光**投射**(Cast)到物体的光源叫做投光物(Light Caster)

### 平行光

​		**当一个光源处于很远的地方时，来自光源的每条光线就会近似于互相平行。不论物体和/或者观察者的位置，看起来好像所有的光都来自于同一个方向。**当我们使用一个假设光源处于<font style="color:red;font-weight:bolder">无限</font>远处的模型时，它就被称为**定向光**，因为它的所有光线都有着相同的方向，它与光源的位置是没有关系的。

​		定向光非常好的一个例子就是太阳。它在实际开发中已经远到在光照计算中可以把它视为无限远了。所以来自太阳的所有光线将被模拟为平行光线，可以在下图看到：

![avatar](/Users/adsionli/Desktop/生产开发/笔记/opengl/光照/image/light_casters_directional.png)

​		因为**所有的光线都是平行的**，所以**物体与光源的相对位置是不重要的**，因为对场景中**每一个物体光的方向都是一致**的。由于光的位置向量保持一致，场景中每个物体的光照计算将会是类似的。

​		我们可以定义一个光线方向向量而不是位置向量来模拟一个定向光。着色器的计算基本保持不变，但这次我们将直接使用光的``direction``向量而不是通过``direction``来计算``lightDir``向量。

```glsl
struct Light{
	vec3 direction;
	vec3 adbient;
	vec3 diffuse;
	vec3 specular;
}

void main(){
	vec3 lightDir = normalize(-light.direction);
}
```

​		注意我们首先对**light.direction向量取反**。我们目前使用的光照计算需求一个从**片段至光源的光线**方向，但人们更习惯定义定向光为一个**从**光源出发的全局方向。所以我们需要对全局光照方向向量取反来改变它的方向，它现在是一个指向光源的方向向量了。而且，记得对向量进行标准化，假设输入向量为一个单位向量是很不明智的。

​		定义光源方向

```c++
lightingShader.setVec3("light.direction", -0.2f, -1.0f, -0.3f);
```

>  我们一直将光的位置和位置向量定义为`vec3`，但一些人会喜欢将所有的向量都定义为`vec4`。当我们将位置向量定义为一个`vec4`时，很重要的一点是要将w分量设置为1.0，这样变换和投影才能正确应用。然而，当我们定义一个方向向量为`vec4`的时候，我们**不想让位移有任何的效果（因为它仅仅代表的是方向）**，所以我们将w分量设置为0.0。

> 方向向量就会像这样来表示：`vec4(0.2f, 1.0f, 0.3f, 0.0f)`。这也可以作为一个快速检测光照类型的工具：你可以检测w分量是否等于1.0，来检测它是否是光的位置向量；w分量等于0.0，则它是光的方向向量，这样就能根据这个来调整光照计算了：
>
> ```c++
> if(lightVector.w == 0.0) // 注意浮点数据类型的误差
>   // 执行定向光照计算
> else if(lightVector.w == 1.0)
>   // 根据光源的位置做光照计算（与上一节一样）
> ```
>
> 你知道吗：这正是旧OpenGL（固定函数式）决定光源是定向光还是位置光源(Positional Light Source)的方法，并根据它来调整光照。





