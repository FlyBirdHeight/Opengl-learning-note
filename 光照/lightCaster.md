## 投光物

>  将光**投射**(Cast)到物体的光源叫做投光物(Light Caster)

### 平行光

​		**当一个光源处于很远的地方时，来自光源的每条光线就会近似于互相平行。不论物体和/或者观察者的位置，看起来好像所有的光都来自于同一个方向。**当我们使用一个假设光源处于<font style="color:red;font-weight:bolder">无限</font>远处的模型时，它就被称为**定向光**，因为它的所有光线都有着相同的方向，它与光源的位置是没有关系的。

​		定向光非常好的一个例子就是太阳。它在实际开发中已经远到在光照计算中可以把它视为无限远了。所以来自太阳的所有光线将被模拟为平行光线，可以在下图看到：

![avatar](/Users/adsionli/Desktop/生产开发/笔记/opengl/光照/image/light_casters_directional.png)

​		因为**所有的光线都是平行的**，所以**物体与光源的相对位置是不重要的**，因为对场景中**每一个物体光的方向都是一致**的。由于光的位置向量保持一致，场景中每个物体的光照计算将会是类似的。

​		我们可以定义一个光线方向向量而不是位置向量来模拟一个定向光。着色器的计算基本保持不变，但这次我们将直接使用光的``direction``向量而不是通过``position``来计算``lightDir``向量。

```glsl
struct Light{
    //光线向量
	vec3 direction;
	vec3 adbient;
	vec3 diffuse;
	vec3 specular;
}

void main(){
	vec3 lightDir = normalize(-light.direction);
}
```

​		注意我们首先对**light.direction向量取反**。我们目前使用的光照计算需求一个从**片段至光源的光线**方向，但人们更习惯定义定向光为一个**从**光源出发的全局方向。所以我们需要对全局光照方向向量取反来改变它的方向，它现在是一个指向光源的方向向量了。而且，记得对向量进行标准化，假设输入向量为一个单位向量是很不明智的。

​		定义光源方向

```c++
lightingShader.setVec3("light.direction", -0.2f, -1.0f, -0.3f);
```

>  我们一直将光的位置和位置向量定义为`vec3`，但一些人会喜欢将所有的向量都定义为`vec4`。当我们将位置向量定义为一个`vec4`时，很重要的一点是要将w分量设置为1.0，这样变换和投影才能正确应用。然而，当我们定义一个方向向量为`vec4`的时候，我们**不想让位移有任何的效果（因为它仅仅代表的是方向）**，所以我们将w分量设置为0.0。

> 方向向量就会像这样来表示：`vec4(0.2f, 1.0f, 0.3f, 0.0f)`。这也可以作为一个快速检测光照类型的工具：你可以检测w分量是否等于1.0，来检测它是否是光的位置向量；w分量等于0.0，则它是光的方向向量，这样就能根据这个来调整光照计算了：
>
> ```c++
> if(lightVector.w == 0.0) // 注意浮点数据类型的误差
>   // 执行定向光照计算
> else if(lightVector.w == 1.0)
>   // 根据光源的位置做光照计算（与上一节一样）
> ```
>
> 你知道吗：这正是旧OpenGL（固定函数式）决定光源是定向光还是位置光源(Positional Light Source)的方法，并根据它来调整光照。

### 点光源

定向光对于照亮整个场景的全局光源是非常棒的，但除了定向光之外我们也需要一些分散在场景中的**点光源(Point Light)**。点光源是处于世界中某一个位置的光源，它会朝着所有方向发光，但光线会随着距离逐渐衰减。想象作为投光物的灯泡和火把，它们都是点光源。

![avatar](C:\Users\adsionli\Desktop\note\Opengl-learning-note\image\light_casters_point.png)

#### 衰减

**随着光线传播距离的增长逐渐削减光的强度通常叫做衰减**

**随距离减少光强度的一种方式是使用一个线性方程。**这样的方程能够随着距离的增长线性地减少光的强度，从而让远处的物体更暗。然而，这样的线性方程通常会看起来比较假。在现实世界中，灯在近处通常会非常亮，但随着距离的增加光源的亮度一开始会下降非常快，但在远处时剩余的光强度就会下降的非常缓慢了。所以，我们需要一个不同的公式来减少光的强度。

下面这个公式根据片段距光源的距离计算了衰减值，之后我们会将它乘以光的强度向量：
$$
\begin{equation} F_{att} = \frac{1.0}{K_c + K_l * d + K_q * d^2} \end{equation}
$$
dd代表了片段距光源的距离。接下来为了计算衰减值，我们定义3个（可配置的）项：常数项Kc、一次项Ki和二次项Kq。

- 常数项通常保持为1.0，它的主要作用是保证分母永远不会比1小，否则的话在某些距离上它反而会增加强度，这肯定不是我们想要的效果。
- 一次项会与距离值相乘，以线性的方式减少强度。
- 二次项会与距离的平方相乘，让光源以二次递减的方式减少强度。二次项在距离比较小的时候影响会比一次项小很多，但当距离值比较大的时候它就会比一次项更大了。

由于二次项的存在，光线会在大部分时候以线性的方式衰退，直到距离变得足够大，让二次项超过一次项，光的强度会以更快的速度下降。这样的结果就是，光在近距离时亮度很高，但随着距离变远亮度迅速降低，最后会以更慢的速度减少亮度。下面这张图显示了在100的距离内衰减的效果：

![avatar](C:\Users\adsionli\Desktop\note\Opengl-learning-note\image\attenuation.png)

#### 选择正确的值

下面这个表格显示了模拟一个（大概）真实的，覆盖特定半径（距离）的光源时，这些项可能取的一些值。第一列指定的是在给定的三项时光所能覆盖的距离。这些值是大多数光源很好的起始点，它们由[Ogre3D的Wiki](http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Point+Light+Attenuation)所提供：

| 距离 | 常数项 | 一次项 | 二次项   |
| :--- | :----- | :----- | :------- |
| 7    | 1.0    | 0.7    | 1.8      |
| 13   | 1.0    | 0.35   | 0.44     |
| 20   | 1.0    | 0.22   | 0.20     |
| 32   | 1.0    | 0.14   | 0.07     |
| 50   | 1.0    | 0.09   | 0.032    |
| 65   | 1.0    | 0.07   | 0.017    |
| 100  | 1.0    | 0.045  | 0.0075   |
| 160  | 1.0    | 0.027  | 0.0028   |
| 200  | 1.0    | 0.022  | 0.0019   |
| 325  | 1.0    | 0.014  | 0.0007   |
| 600  | 1.0    | 0.007  | 0.0002   |
| 3250 | 1.0    | 0.0014 | 0.000007 |

你可以看到，常数项$K_c$在所有的情况下都是1.0。一次项$K_l$为了覆盖更远的距离通常都很小，二次项$K_q$甚至更小。尝试对这些值进行实验，看看它们在你的实现中有什么效果。在我们的环境中，32到100的距离对大多数的光源都足够了。

#### 衰减的代码实现

设置点光源的衰减三个参数

```glsl
struct Light {
    //这里不是用定向光，所以还是改为光源方向
	vec3 position;
	
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
	//常数项
	float constant;
    //线性改变,一次项
	float linear;
    //二次项
	float quadratic;
}
```

```c++
//对三个参数进行赋值
lightingShader.setFloat("light.constant",  1.0f);
lightingShader.setFloat("light.linear",    0.09f);
lightingShader.setFloat("light.quadratic", 0.032f);
```

```glsl
//在片段作色器中计算衰减，并处理环境光、漫反射光、镜面反射光
float distance = length(light.position - FragPos);
float attenuation = 1.0/ (light.constant + light.linear * distance + light.quadratic * pow(distance,2));

ambient *= attenuation;
diffuse  *= attenuation;
specular *= attenuation;
```

### 聚光

**聚光是位于环境中某个位置的光源，它只朝一个特定方向而不是所有方向照射光线。**这样的结果就是只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗。聚光很好的例子就是路灯或手电筒。

**OpenGL中聚光是用一个世界空间位置、一个方向和一个切光角(Cutoff Angle)来表示的**，切光角指定了聚光的半径（译注：是圆锥的半径不是距光源距离那个半径）。对于每个片段，我们会计算片段是否位于聚光的切光方向之间（也就是在锥形内），如果是的话，我们就会相应地照亮片段。下面这张图会让你明白聚光是如何工作的：

![avatar](C:\Users\adsionli\Desktop\note\Opengl-learning-note\image\light_casters_spotlight_angles.png)