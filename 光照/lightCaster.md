## 投光物

>  将光**投射**(Cast)到物体的光源叫做投光物(Light Caster)

### 平行光

​		**当一个光源处于很远的地方时，来自光源的每条光线就会近似于互相平行。不论物体和/或者观察者的位置，看起来好像所有的光都来自于同一个方向。**当我们使用一个假设光源处于<font style="color:red;font-weight:bolder">无限</font>远处的模型时，它就被称为**定向光**，因为它的所有光线都有着相同的方向，它与光源的位置是没有关系的。

​		定向光非常好的一个例子就是太阳。它在实际开发中已经远到在光照计算中可以把它视为无限远了。所以来自太阳的所有光线将被模拟为平行光线，可以在下图看到：

![avatar](/Users/adsionli/Desktop/生产开发/笔记/opengl/光照/image/light_casters_directional.png)

​		因为**所有的光线都是平行的**，所以**物体与光源的相对位置是不重要的**，因为对场景中**每一个物体光的方向都是一致**的。由于光的位置向量保持一致，场景中每个物体的光照计算将会是类似的。

​		我们可以定义一个光线方向向量而不是位置向量来模拟一个定向光。着色器的计算基本保持不变，但这次我们将直接使用光的``direction``向量而不是通过``position``来计算``lightDir``向量。

```glsl
struct Light{
    //光线向量
	vec3 direction;
	vec3 adbient;
	vec3 diffuse;
	vec3 specular;
}

void main(){
	vec3 lightDir = normalize(-light.direction);
}
```

​		注意我们首先对**light.direction向量取反**。我们目前使用的光照计算需求一个从**片段至光源的光线**方向，但人们更习惯定义定向光为一个**从**光源出发的全局方向。所以我们需要对全局光照方向向量取反来改变它的方向，它现在是一个指向光源的方向向量了。而且，记得对向量进行标准化，假设输入向量为一个单位向量是很不明智的。

​		定义光源方向

```c++
lightingShader.setVec3("light.direction", -0.2f, -1.0f, -0.3f);
```

>  我们一直将光的位置和位置向量定义为`vec3`，但一些人会喜欢将所有的向量都定义为`vec4`。当我们将位置向量定义为一个`vec4`时，很重要的一点是要将w分量设置为1.0，这样变换和投影才能正确应用。然而，当我们定义一个方向向量为`vec4`的时候，我们**不想让位移有任何的效果（因为它仅仅代表的是方向）**，所以我们将w分量设置为0.0。

> 方向向量就会像这样来表示：`vec4(0.2f, 1.0f, 0.3f, 0.0f)`。这也可以作为一个快速检测光照类型的工具：你可以检测w分量是否等于1.0，来检测它是否是光的位置向量；w分量等于0.0，则它是光的方向向量，这样就能根据这个来调整光照计算了：
>
> ```c++
> if(lightVector.w == 0.0) // 注意浮点数据类型的误差
>   // 执行定向光照计算
> else if(lightVector.w == 1.0)
>   // 根据光源的位置做光照计算（与上一节一样）
> ```
>
> 你知道吗：这正是旧OpenGL（固定函数式）决定光源是定向光还是位置光源(Positional Light Source)的方法，并根据它来调整光照。

### 点光源

定向光对于照亮整个场景的全局光源是非常棒的，但除了定向光之外我们也需要一些分散在场景中的**点光源(Point Light)**。点光源是处于世界中某一个位置的光源，它会朝着所有方向发光，但光线会随着距离逐渐衰减。想象作为投光物的灯泡和火把，它们都是点光源。

![avatar](C:\Users\adsionli\Desktop\note\Opengl-learning-note\image\light_casters_point.png)

#### 衰减

**随着光线传播距离的增长逐渐削减光的强度通常叫做衰减**

**随距离减少光强度的一种方式是使用一个线性方程。**这样的方程能够随着距离的增长线性地减少光的强度，从而让远处的物体更暗。然而，这样的线性方程通常会看起来比较假。在现实世界中，灯在近处通常会非常亮，但随着距离的增加光源的亮度一开始会下降非常快，但在远处时剩余的光强度就会下降的非常缓慢了。所以，我们需要一个不同的公式来减少光的强度。

下面这个公式根据片段距光源的距离计算了衰减值，之后我们会将它乘以光的强度向量：
$$
\begin{equation} F_{att} = \frac{1.0}{K_c + K_l * d + K_q * d^2} \end{equation}
$$
$d$代表了片段距光源的距离。接下来为了计算衰减值，我们定义3个（可配置的）项：常数项Kc、一次项Ki和二次项Kq。

- 常数项通常保持为1.0，它的主要作用是保证分母永远不会比1小，否则的话在某些距离上它反而会增加强度，这肯定不是我们想要的效果。
- 一次项会与距离值相乘，以线性的方式减少强度。
- 二次项会与距离的平方相乘，让光源以二次递减的方式减少强度。二次项在距离比较小的时候影响会比一次项小很多，但当距离值比较大的时候它就会比一次项更大了。

由于二次项的存在，光线会在大部分时候以线性的方式衰退，直到距离变得足够大，让二次项超过一次项，光的强度会以更快的速度下降。这样的结果就是，光在近距离时亮度很高，但随着距离变远亮度迅速降低，最后会以更慢的速度减少亮度。下面这张图显示了在100的距离内衰减的效果：

![avatar](C:\Users\adsionli\Desktop\note\Opengl-learning-note\image\attenuation.png)

#### 选择正确的值

下面这个表格显示了模拟一个（大概）真实的，覆盖特定半径（距离）的光源时，这些项可能取的一些值。第一列指定的是在给定的三项时光所能覆盖的距离。这些值是大多数光源很好的起始点，它们由[Ogre3D的Wiki](http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Point+Light+Attenuation)所提供：

| 距离 | 常数项 | 一次项 | 二次项   |
| :--- | :----- | :----- | :------- |
| 7    | 1.0    | 0.7    | 1.8      |
| 13   | 1.0    | 0.35   | 0.44     |
| 20   | 1.0    | 0.22   | 0.20     |
| 32   | 1.0    | 0.14   | 0.07     |
| 50   | 1.0    | 0.09   | 0.032    |
| 65   | 1.0    | 0.07   | 0.017    |
| 100  | 1.0    | 0.045  | 0.0075   |
| 160  | 1.0    | 0.027  | 0.0028   |
| 200  | 1.0    | 0.022  | 0.0019   |
| 325  | 1.0    | 0.014  | 0.0007   |
| 600  | 1.0    | 0.007  | 0.0002   |
| 3250 | 1.0    | 0.0014 | 0.000007 |

你可以看到，常数项$K_c$在所有的情况下都是1.0。一次项$K_l$为了覆盖更远的距离通常都很小，二次项$K_q$甚至更小。尝试对这些值进行实验，看看它们在你的实现中有什么效果。在我们的环境中，32到100的距离对大多数的光源都足够了。

#### 衰减的代码实现

设置点光源的衰减三个参数

```glsl
struct Light {
    //这里不是用定向光，所以还是改为光源方向
	vec3 position;
	
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
	//常数项
	float constant;
    //线性改变,一次项
	float linear;
    //二次项
	float quadratic;
}
```

```c++
//对三个参数进行赋值
lightingShader.setFloat("light.constant",  1.0f);
lightingShader.setFloat("light.linear",    0.09f);
lightingShader.setFloat("light.quadratic", 0.032f);
```

```glsl
//在片段作色器中计算衰减，并处理环境光、漫反射光、镜面反射光
float distance = length(light.position - FragPos);
float attenuation = 1.0/ (light.constant + light.linear * distance + light.quadratic * pow(distance,2));

ambient *= attenuation;
diffuse  *= attenuation;
specular *= attenuation;
```

### 聚光

**聚光是位于环境中某个位置的光源，它只朝一个特定方向而不是所有方向照射光线。**这样的结果就是只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗。聚光很好的例子就是路灯或手电筒。

**OpenGL中聚光是用一个世界空间位置、一个方向和一个切光角(Cutoff Angle)来表示的**，切光角指定了聚光的半径（译注：是圆锥的半径不是距光源距离那个半径）。对于每个片段，我们会计算片段是否位于聚光的切光方向之间（也就是在锥形内），如果是的话，我们就会相应地照亮片段。下面这张图会让你明白聚光是如何工作的：

![avatar](C:\Users\adsionli\Desktop\note\Opengl-learning-note\image\light_casters_spotlight_angles.png)

- `LightDir`：从片段指向光源的向量。
- `SpotDir`：聚光所指向的方向。
- `Phi`$\phi$：指定了聚光半径的切光角。落在这个角度之外的物体都不会被这个聚光所照亮。

- `Theta`$\theta$：LightDir向量和SpotDir向量之间的夹角。在聚光内部的话$\theta$值应该比$\phi$值小。

所以我们要做的就是计算LightDir向量和SpotDir向量之间的点积（还记得它会返回两个单位向量夹角的余弦值吗？），并将它与切光角$\phi$值对比。

#### 手电筒

**手电筒(Flashlight)是一个位于观察者位置的聚光，通常它都会瞄准玩家视角的正前方**。基本上说，手电筒就是普通的聚光，但它的位置和方向会随着玩家的位置和朝向不断更新。

在片段着色器中我们需要的值有聚光的位置向量（来计算光的方向向量）、聚光的方向向量和一个切光角。我们可以将它们储存在Light结构体中：

```glsl
struct Light {
    vec3  position;
    vec3  direction;
    float cutOff;
    ...
};
```

```c++
lightingShader.setVec3("light.position",  camera.Position);
lightingShader.setVec3("light.direction", camera.Front);
lightingShader.setFloat("light.cutOff",   glm::cos(glm::radians(12.5f)));
```

我们并没有给切光角设置一个角度值，反而是用角度值计算了一个余弦值，将余弦结果传递到片段着色器中。这样做的原因是在片段着色器中，我们会计算`LightDir`和`SpotDir`向量的点积，这个点积返回的将是一个余弦值而不是角度值，所以我们不能直接使用角度值和余弦值进行比较。为了获取角度值我们需要计算点积结果的反余弦，这是一个开销很大的计算。所以为了节约一点性能开销，我们将会计算切光角对应的余弦值，并将它的结果传入片段着色器中。由于这两个角度现在都由余弦角来表示了，我们可以直接对它们进行比较而不用进行任何开销高昂的计算。

切光角的设置主要是为了_节省开销_

```glsl
//计算片段指向光源方向的向量与聚光方向向量的点乘,取反的是因为我们想让向量指向光源而不是从光源出发
float theta = dot(lightDir,normalize(-light.direction));
if(theta > light.cutOff) {       
  // 执行光照计算
}else{
    // 否则，使用环境光，让场景在聚光之外时不至于完全黑暗
  color = vec4(light.ambient * vec3(texture(material.diffuse, TexCoords)), 1.0);
}  
```

这里会发现使用的是theta > light.cutOff，这个原因就是因为余弦图像下图所示：

![avatar](C:\Users\adsionli\Desktop\note\Opengl-learning-note\image\light_casters_cos.png)

它是随角度增大而变小的(在0°-180°范围内)，所以当theta大的时候，角度一定更小

#### 平滑/软化边缘

将上一部分的圆锥体当作内圆锥，在外面再套一个大一些的外圆锥体，使内圆锥到外圆锥之间的光变化逐渐减暗，直到外圆锥的边界。再定义一个余弦值来代表聚光方向向量和外圆锥向量（等于它的半径）的夹角。然后，如果一个片段处于内外圆锥之间，将会给它计算出一个0.0到1.0之间的强度值。如果片段在内圆锥之内，它的强度就是1.0，如果在外圆锥之外强度值就是0.0。

用下面这个公式来计算这个值：
$$
\begin{equation} I = \frac{cos\theta - cos\gamma}{\epsilon} \end{equation}
$$
这里ϵ(Epsilon)是内（ϕ）和外圆锥（γ）之间的余弦值差（ϵ=ϕ−γ）。最终的I值就是在当前片段聚光的强度。

这里的$\theta$是指LightDir向量和SpotDir向量之间的夹角。$\theta$的范围在[0,$\gamma$]才会有聚光效果！

| cos$\theta$ | $\theta$ | cos$\phi$ | $\phi$ | cos$\gamma$ | $\gamma$ | ϵ = (cos$\phi$-cos$\gamma$) | $I$                           |
| :---------- | :------- | :-------- | :----- | :---------- | :------- | :-------------------------- | :---------------------------- |
| 0.87        | 30       | 0.91      | 25     | 0.82        | 35       | 0.91 - 0.82 = 0.09          | 0.87 - 0.82 / 0.09 = 0.56     |
| 0.9         | 26       | 0.91      | 25     | 0.82        | 35       | 0.91 - 0.82 = 0.09          | 0.9 - 0.82 / 0.09 = 0.89      |
| 0.97        | 14       | 0.91      | 25     | 0.82        | 35       | 0.91 - 0.82 = 0.09          | 0.97 - 0.82 / 0.09 = 1.67     |
| 0.83        | 34       | 0.91      | 25     | 0.82        | 35       | 0.91 - 0.82 = 0.09          | 0.83 - 0.82 / 0.09 = 0.11     |
| 0.64        | 50       | 0.91      | 25     | 0.82        | 35       | 0.91 - 0.82 = 0.09          | 0.64 - 0.82 / 0.09 = -2.0     |
| 0.966       | 15       | 0.9978    | 12.5   | 0.953       | 17.5     | 0.966 - 0.953 = 0.0448      | 0.966 - 0.953 / 0.0448 = 0.29 |

我们现在有了一个在聚光外是负的，在内圆锥内大于1.0的，在边缘处于两者之间的强度值了。如果我们正确地约束(Clamp)这个值，在片段着色器中就不再需要`if-else`了，我们能够使用计算出来的强度值直接乘以光照分量：

```glsl
float theta     = dot(lightDir, normalize(-light.direction));
float epsilon   = light.cutOff - light.outerCutOff;
float intensity = clamp((theta - light.outerCutOff) / epsilon, 0.0, 1.0);    
...
// 将不对环境光做出影响，让它总是能有一点光
diffuse  *= intensity;
specular *= intensity;
...
```

